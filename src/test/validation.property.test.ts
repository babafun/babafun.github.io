/**
 * Property-based tests for song validation
 * 
 * These tests verify that the WASM validation functions correctly identify
 * valid and invalid song data structures according to the requirements.
 */

import { describe, it, expect, beforeAll } from 'vitest';
import * as fc from 'fast-check';
import { initWasm, validateSong } from '../wasm/bindings';
import { songArbitrary } from '../../test/arbitraries';
import type { Song } from '../types/music';

describe('Property 1: Song Validation', () => {
  beforeAll(async () => {
    // Initialize WASM module before running tests
    await initWasm();
  });

  /**
   * **Validates: Requirements 2.2, 2.3, 2.4, 2.5**
   * 
   * For any object claiming to be a Song, the validation function should accept it 
   * if and only if it contains all required fields (id, title, albumName, releaseType, 
   * hasContentId, streamingLink, license) with correct types.
   */
  it('should accept valid songs and reject invalid ones', () => {
    fc.assert(
      fc.property(fc.anything(), (obj: any) => {
        // Handle cases where JSON.stringify returns undefined
        let songJson: string;
        try {
          const jsonResult = JSON.stringify(obj);
          if (jsonResult === undefined) {
            songJson = 'undefined';
          } else {
            songJson = jsonResult;
          }
        } catch (error) {
          // Handle circular references or other JSON.stringify errors
          songJson = 'invalid';
        }
        
        const validationResult = validateSong(songJson);
        const isValid = validationResult === '';
        
        // Check if object has all required fields with correct types
        const hasAllFields = 
          typeof obj === 'object' &&
          obj !== null &&
          typeof obj.id === 'string' &&
          typeof obj.title === 'string' &&
          typeof obj.albumName === 'string' &&
          ['Independent', 'NCS', 'Monstercat'].includes(obj.releaseType) &&
          typeof obj.hasContentId === 'boolean' &&
          typeof obj.streamingLink === 'string' &&
          typeof obj.license === 'string';
        
        // The validation result should match our field check
        return isValid === hasAllFields;
      }),
      { numRuns: 1000 }
    );
  });

  it('should always accept properly generated songs', () => {
    fc.assert(
      fc.property(songArbitrary, (song: Song) => {
        const songJson = JSON.stringify(song);
        const validationResult = validateSong(songJson);
        
        // All songs generated by our arbitrary should be valid
        expect(validationResult).toBe('');
        return true;
      }),
      { numRuns: 500 }
    );
  });

  it('should reject songs with missing required fields', () => {
    fc.assert(
      fc.property(songArbitrary, (song: Song) => {
        // Test removing each required field
        const requiredFields = ['id', 'title', 'albumName', 'releaseType', 'hasContentId', 'streamingLink', 'license'];
        
        for (const fieldToRemove of requiredFields) {
          const incompleteObj = { ...song };
          delete (incompleteObj as any)[fieldToRemove];
          
          const songJson = JSON.stringify(incompleteObj);
          const validationResult = validateSong(songJson);
          
          // Should be invalid when missing required field
          expect(validationResult).not.toBe('');
        }
        
        return true;
      }),
      { numRuns: 100 }
    );
  });

  it('should reject songs with incorrect field types', () => {
    fc.assert(
      fc.property(songArbitrary, (song: Song) => {
        // Test with wrong types for each field
        const wrongTypes = [
          { ...song, id: 123 }, // number instead of string
          { ...song, title: null }, // null instead of string
          { ...song, albumName: [] }, // array instead of string
          { ...song, releaseType: 'InvalidType' }, // invalid enum value
          { ...song, hasContentId: 'true' }, // string instead of boolean
          { ...song, streamingLink: 42 }, // number instead of string
          { ...song, license: undefined }, // undefined instead of string
        ];
        
        for (const wrongObj of wrongTypes) {
          const songJson = JSON.stringify(wrongObj);
          const validationResult = validateSong(songJson);
          
          // Should be invalid with wrong types
          expect(validationResult).not.toBe('');
        }
        
        return true;
      }),
      { numRuns: 50 }
    );
  });

  it('should reject invalid JSON strings', () => {
    const invalidJsonStrings = [
      'invalid json',
      '{"incomplete": ',
      'null',
      'undefined',
      '',
      '[]',
      'true',
      '42'
    ];

    for (const invalidJson of invalidJsonStrings) {
      const validationResult = validateSong(invalidJson);
      expect(validationResult).not.toBe('');
    }
  });

  it('should provide meaningful error messages for invalid songs', () => {
    const testCases = [
      { obj: {}, expectedError: 'missing' },
      { obj: { id: 123 }, expectedError: 'type' },
      { obj: { id: 'test', title: 'test', albumName: 'test', releaseType: 'Invalid', hasContentId: true, streamingLink: 'test', license: 'test' }, expectedError: 'releaseType' }
    ];

    for (const testCase of testCases) {
      const songJson = JSON.stringify(testCase.obj);
      const validationResult = validateSong(songJson);
      
      expect(validationResult).not.toBe('');
      expect(validationResult.length).toBeGreaterThan(0);
      // Error message should be descriptive (not just empty or generic)
      expect(typeof validationResult).toBe('string');
    }
  });
});